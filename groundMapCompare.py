## 	Compares manual ground truths generated by trainer.py with "ground truths" generated from Vicon data with mapper.
#	Used to check accuracy of vicon mapping
## 	Note: maps are generated using extrinsics derived from correspondences made with trainer.py. Compare against train set or distinct test set .

import xml.etree.ElementTree as ET
import cv2, sys
from math import sqrt
from eagleeye import EasyArgs
import matplotlib.pyplot as plt
import numpy as np


#Lens centres, to get radius.
#MAKE SURE THESE ARE FROM THE SAME INTRINSICS USED TO GENERATE THE MAP YOU'RE COMPARING.
BTN_CX = 488.17532663 + 960 #488.17532663 for Session1, intrinsicsk6
BTN_CY = 478.94638883 #478.94638883 for Session1, intrinsicsk6
BACK_CX = 459.48069868 #459.48069868 for Session1, intrinsicsk6
BACK_CY = 489.75730085 #489.75730085 for Session1, intrinsicsk6
RATIO = 2.89935483871 #MAKE SURE RATIO COMES FROM SAME RATIO USED IN TRAINER. 2.89935483871 for Session1 training csv


def usage():
	print ''

#TODO: WHY DO I NEED -1? without is better accuracy. Trainer.py doesn't have same mapping frame as compare_trainer...?
def c2v(cFrame): #Camera frame to Vicon frame
	return round((cFrame - 36) * RATIO) - 1 #Don't need 181+... since vicon frames are already trimmed (restrict method) in mapper, and start from 0 (0 is 181)

#returns 2 dictionaries (button/backside) of {camFrame: (x,y), ...}
#  from extrinsic generating manual groundtruth correspondences xml
def getFrameCoords_gt(fileName):
	coordsButton = {}
	coordsBack = {}
	for child in ET.parse(fileName).getroot():
		for frame in child.findall('frame'):
			if child.tag == 'buttonside':
				coordsButton[int(frame.get('num'))] = (int(float(frame.find('plane').get('x'))+960),
													   int(float(frame.find('plane').get('y'))))
			elif child.tag == 'backside':
				coordsBack[int(frame.get('num'))] = (int(float(frame.find('plane').get('x'))),
													 int(float(frame.find('plane').get('y'))))
			else:
				print("ERROR - in getFrameCoords_gt")
	return coordsButton, coordsBack

#returns 2 dictionaries (button/backside) of {viconFrame: (x,y), ...}
#  from mapped xml
def getFrameCoords_map(fileName):
	coordsButton = {}
	coordsBack = {}

	for child in ET.parse(fileName).getroot():
		frame = int(child.find('frame').get('number'))
		lens = child.find('object').get('lens')
		if lens == 'Buttonside':
			coordsButton[frame] = (int(float(child.find('object').find('centroid').attrib['x'])), #TODO: do Gwilyn's int casts lower accuracy?
								   int(float(child.find('object').find('centroid').attrib['y'])))
		elif lens == 'Backside':
			coordsBack[frame] = (int(float(child.find('object').find('centroid').attrib['x'])),
								 int(float(child.find('object').find('centroid').attrib['y'])))

	return coordsButton, coordsBack

#Just distance between two points
def calReprojError(img_pt, reproj_pt):
	if img_pt and reproj_pt is not None:
		if not(img_pt < 0) and not(reproj_pt < 0):
			return cv2.norm(img_pt, reproj_pt, cv2.NORM_L2) # Euclidean distance
	return -1.0

#gets the reprojection error for the corresponding vicon frame and lens
def calReprojErrors(gtCoords, mapCoords, side):
	errs = {}
	for frame in gtCoords:
		viconFrame = c2v(frame)
		#print 'frame: ', frame, ', viconframe: ', viconFrame
		if viconFrame in mapCoords:
			errs[frame] = calReprojError(gtCoords[frame], mapCoords[viconFrame])
		else:
			print 'skipped (vicon mapped to wrong lens): (C, V, gtSide)', (frame, viconFrame, side)
	return errs

#Final reprojection error (RMS, Arthimetical mean)
def calReprojList(reprojerror_list, maxPoss):
	total_error = 0.0
	if len(reprojerror_list) > 0:
		for frm in reprojerror_list:
			total_error += float(reprojerror_list[frm]["err"])

		arth_mean = total_error / len(reprojerror_list)
		rms = sqrt(arth_mean)      # according to opencv calibrateCamera2

		print "List of Reprojection Error:"
		for frame in reprojerror_list:
			print "Frame: {} | Reproj Err: {} | Radius: {} | (x,y): {} | v(x,y): {}".format('C'+str(frame)+'/V'+str(reprojerror_list[frame]["vFrame"]),
																							reprojerror_list[frame]["err"],
																							reprojerror_list[frame]["rad"],
																							reprojerror_list[frame]['xy'],
																							reprojerror_list[frame]['xyv'])
		print "Number of matched training points: {}".format(len(reprojerror_list)), 'of: ', maxPoss
		print "RMS: {} pixels".format(rms)
		print "Arithmetical mean: {} pixels".format(arth_mean)
		print "\n"
	else:
		print "Reprojection Error: No Data"

#Scatterplot - takes dictionary {frame#: {'rms': rms, 'rad': rad}, ... }
def showScatter(reprojDict, name, imagePrefix):
	error = []
	radius = []
	for frame in reprojDict:
		error.append(reprojDict[frame]['err'])
		radius.append(reprojDict[frame]['rad'])
	plt.scatter(radius, error)
	plt.xlabel('Radius (px)')
	plt.ylabel('Error (px)')
	plt.title(name)
	imageName = imagePrefix+name+'.png'
	plt.savefig(imageName)
	plt.show()


def main(sysargs):
	args = EasyArgs(sysargs)
	gtFile = args.gt
	map = args.map
	imagePrefix = args.image_prefix
	print 'PREF: ', imagePrefix
	print 'GTFILE: ', gtFile
	print 'MAP: ', map

	#Manual and mapped groundtruths.
	#MAKE SURE GT ARE THE SAME CORRESPONDENCES USED TO GENERATE THE MAP IF TESTING TRAINING ERROR.
	#IF YOU CHANGE THE MAP, ENSURE CENTRES UP TOP ARE CHANGED
	gtCoordsButton, gtCoordsBack = getFrameCoords_gt(gtFile) #groundtruth frames (test set)
	mapCoordsButton, mapCoordsBack = getFrameCoords_map(map) #all mapped vicon frames
	#print 'btn_gt: ', gtCoordsButton
	#print 'back_gt: ', gtCoordsBack
	#print 'btn_map: ', mapCoordsButton
	#print 'back_map: ', mapCoordsBack, '\n'

	#Get err between map and GTs. only does cam frames' corresponding vicon frames
	btnErrs = calReprojErrors(gtCoordsButton, mapCoordsButton, 'btn')
	backErrs = calReprojErrors(gtCoordsBack, mapCoordsBack, 'back')
	print 'btnErrs: ', btnErrs
	print 'backErrs: ', backErrs, '\n'

	#Converting to Gwilyn's format
	reprojDictBtn = {}
	for frame in btnErrs:
		reprojDictBtn[frame] = {'err': btnErrs[frame],
									'rad': calReprojError((BTN_CX, BTN_CY), gtCoordsButton[frame]), #calReprojError just gets distance between two points.
									'vFrame': c2v(frame),
									'xy': gtCoordsButton[frame], #debugging
									'xyv': mapCoordsButton[round((frame - 36) * RATIO)] #debugging
								}
	print("Buttonside")
	calReprojList(reprojDictBtn, len(gtCoordsButton)) #
	showScatter(reprojDictBtn, 'btn', imagePrefix)


	reprojDictBack = {}
	for frame in backErrs:
		reprojDictBack[frame] = {'err': backErrs[frame],
									'rad': calReprojError((BACK_CX, BACK_CY), gtCoordsBack[frame]), #calReprojError just gets distance between two points.
									'vFrame': c2v(frame),
									'xy': gtCoordsBack[frame], #debugging
									'xyv': mapCoordsBack[round((frame - 36) * RATIO)] #debugging
								}
	print("Backside:")
	calReprojList(reprojDictBack, len(gtCoordsBack))
	showScatter(reprojDictBack, 'back', imagePrefix)

if __name__ == "__main__":
	exit(main(sys.argv))