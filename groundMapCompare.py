## 	Compares manual ground truths generated by trainer.py with "ground truths" gereated from Vicon data with mapper.
#	Used to check accuracy of vicon mapping
## 	Note: maps are generated using extrinsics derived from correspondences made with trainer.py. Compare against train set or distinct test set .

import xml.etree.ElementTree as ET
import cv2
from math import sqrt
import matplotlib.pyplot as plt
import numpy as np


#Lens centres, to get radius.
#MAKE SURE THESE ARE FROM THE SAME EXTRINSICS USED TO GENERATE THE MAP YOU'RE COMPARING. TODO: have mapper write these out somewhere
BTN_CX = 488.17532663
BTN_CY = 478.94638883
BACK_CX = 461.350275
BACK_CY = 485.2680423
RATIO = 2.9


#returns 2 dictionaries (buttone/backside) of (x, y) tuples with camera frame as key
#  from extrinsic generating manual groudtruth correspondences xml
def getFrameCoords_gt(fileName):
	coordsButton = {}
	coordsBack = {}
	for child in ET.parse(fileName).getroot():
		for frame in child.findall('frame'):
			if child.tag == 'buttonside':
				coordsButton[int(frame.get('num'))] = (int(frame.find('plane').get('x')), int(frame.find('plane').get('y')))
			elif child.tag == 'backside':
				coordsBack[int(frame.get('num'))] = (int(frame.find('plane').get('x')), int(frame.find('plane').get('y')))
			else:
				print("ERROR - in getFrameCoords_gt")
	return coordsButton, coordsBack

#returns 2 dictionaries (buttone/backside) of (x, y) tuples with vicon frame as key
#  from mapped xml
def getFrameCoords_map(fileName):
	coordsButton = {}
	coordsBack = {}

	for child in ET.parse(fileName).getroot():
		frame = int(child.find('frame').get('number'))
		lens = child.find('object').get('lens')
		if lens == 'Buttonside':
			coordsButton[frame] = (float(child.find('object').find('centroid').attrib['x']), float(child.find('object').find('centroid').attrib['y']))
		elif lens == 'Backside':
			coordsBack[frame] = (float(child.find('object').find('centroid').attrib['x']), float(child.find('object').find('centroid').attrib['y']))

	return coordsButton, coordsBack

#Just distance between two points
def calReprojError(img_pt, reproj_pt):
	if img_pt and reproj_pt is not None:
		if not(img_pt < 0) and not(reproj_pt < 0):
			return cv2.norm(img_pt, reproj_pt, cv2.NORM_L2) # Euclidean distance
	return -1.0

#Final reprojection error (RMS, Arthimetical mean)
def calReprojList(reprojerror_list, maxPoss):
	total_error = 0.0
	if len(reprojerror_list) > 0:
		for frm in reprojerror_list:
			total_error += float(reprojerror_list[frm]["rms"])

		arth_mean = total_error / len(reprojerror_list)
		rms = sqrt(arth_mean)      # according to opencv calibrateCamera2

		print "List of Reprojection Error:"
		for reproj in reprojerror_list:
			print "Frame: {} | Reproj Err: {} | Radius: {}".format(reproj, reprojerror_list[reproj]["rms"], reprojerror_list[reproj]["rad"])
		print "Number of matched training points: {}".format(len(reprojerror_list)), 'of: ', maxPoss
		print "RMS: {} pixels".format(rms)
		print "Arithmetical mean: {} pixels".format(arth_mean)
		print "\n"
	else:
		print "Reprojection Error: No Data"

#gets the reprojection error for the corresponding vicon frame and lens
def calReprojErrors(gtCoords, mapCoords):
	errs = {}
	for frame in gtCoords:
		viconFrame = round(181 + (frame - 36) * RATIO)    #TODO: not exact, might want to read in vicon x coord in _gt, use that to get csv row. Wait... Why don't we just get the vicon frame as well as the camera frame when making manual groundtruths...?
		#print 'frame: ', frame, ', viconframe: ', viconFrame
		if viconFrame in mapCoords: #TODO: The manual groundtruth may be in one lense, while the vicon has put it in the other
			errs[frame] = calReprojError(gtCoords[frame], mapCoords[viconFrame])
		#else:
			#print 'skipped'
	return errs

#Scatterplot - takes dictionary {frame#: {'rms': rms, 'rad': rad}, ... }
def showScatter(reprojDict):
	error = []
	radius = []
	for frame in reprojDict:
		error.append(reprojDict[frame]['rms'])
		radius.append(reprojDict[frame]['rad'])
	plt.scatter(error, radius)
	plt.show()

gtCoordsButton, gtCoordsBack = getFrameCoords_gt('D:/ACL/Session1/workingFiles/peter_s1_train.xml') #groundtruth frames (train set)
#gtCoordsButton, gtCoordsBack = getFrameCoords_gt('D:/ACL/Session1/workingFiles/testPoints.xml') #groundtruth frames (test set)
mapCoordsButton, mapCoordsBack = getFrameCoords_map('D:/ACL/Session1/workingFiles/intrinsicMaps/mapk6.xml') #all mapped vicon frames
print 'btn_gt: ', gtCoordsButton
print 'back_gt: ', gtCoordsBack
print 'btn_map: ', mapCoordsButton
print 'back_map: ', mapCoordsBack, '\n'

btnErrs = calReprojErrors(gtCoordsButton, mapCoordsButton) #only does cam frames' corresponding vicon frames'
backErrs = calReprojErrors(gtCoordsBack, mapCoordsBack)
print 'btnErrs: ', btnErrs
print 'backErrs: ', backErrs, '\n'

#Converting to Gwilyn's format
reprojDictBtn = {}
for frame in btnErrs:
	#if btnErrs[frame] < 1000: #TODO: determine outliers, separate lenses might remove these
	reprojDictBtn[frame] = {'rms': btnErrs[frame],
								'rad': calReprojError((BTN_CX, BTN_CY), (gtCoordsButton[frame][0], gtCoordsButton[frame][1])) #calReprojError just gets distance between two points.
							}
print reprojDictBtn
calReprojList(reprojDictBtn, len(gtCoordsButton))

reprojDictBack = {}
for frame in backErrs:
	#if backErrs[frame] < 1000: #TODO: determine outliers, separate lenses might remove these
	reprojDictBack[frame] = {'rms': backErrs[frame],
							 	'rad': calReprojError((BACK_CX, BACK_CY), (gtCoordsBack[frame][0], gtCoordsBack[frame][1])) #calReprojError just gets distance between two points.
							}
calReprojList(reprojDictBack, len(gtCoordsBack))

showScatter(reprojDictBtn)
showScatter(reprojDictBack)